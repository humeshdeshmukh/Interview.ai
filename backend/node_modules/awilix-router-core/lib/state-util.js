"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("./util");
var symbols_1 = require("./symbols");
/**
 * Rolls up state so paths are joined, middleware rolled into
 * the correct order, etc.
 *
 * @param state
 */
function rollUpState(state) {
    var result = new Map();
    state.methods.forEach(function (method, key) {
        result.set(key, {
            paths: concatPaths(state.root.paths, method.paths),
            beforeMiddleware: state.root.beforeMiddleware.concat(method.beforeMiddleware),
            afterMiddleware: method.afterMiddleware.concat(state.root.afterMiddleware),
            verbs: method.verbs
        });
    });
    return result;
}
exports.rollUpState = rollUpState;
/**
 * Given a decorated class or a controller builder, returns a normalized
 * target + state object. For example, if using the controller builder,
 * we need to use the `target` property. If using decorators, the required
 * value *is* the target.
 *
 * @param src
 * @returns The normalized target + state, or `null` if not applicable.
 */
function getStateAndTarget(src) {
    var state = getState(src);
    if (!state) {
        return null;
    }
    var target = src[symbols_1.IS_CONTROLLER_BUILDER]
        ? src.target
        : src;
    return { target: target, state: state };
}
exports.getStateAndTarget = getStateAndTarget;
/**
 * Adds a route to the state.
 *
 * @param state
 * @param methodName
 * @param path
 */
function addRoute(state, methodName, path) {
    var config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        paths: util_1.uniq(config.paths.concat([path]))
    });
}
exports.addRoute = addRoute;
/**
 * Adds middleware that runs before the method on the specified config.
 *
 * @param state
 * @param methodName
 * @param middleware
 */
function addBeforeMiddleware(state, methodName, middleware) {
    var config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        beforeMiddleware: addMiddleware(config.beforeMiddleware, middleware)
    });
}
exports.addBeforeMiddleware = addBeforeMiddleware;
/**
 * Adds middleware that runs after the method on the specified config.
 *
 * @param state
 * @param methodName
 * @param middleware
 */
function addAfterMiddleware(state, methodName, middleware) {
    var config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        afterMiddleware: addMiddleware(config.afterMiddleware, middleware)
    });
}
exports.addAfterMiddleware = addAfterMiddleware;
/**
 * Adds middleware that runs after the method on the specified config.
 *
 * @param state
 * @param methodName
 * @param value
 */
function addHttpVerbs(state, methodName, value) {
    var config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        verbs: util_1.uniq(config.verbs.concat(value))
    });
}
exports.addHttpVerbs = addHttpVerbs;
/**
 * Gets or creates a method config.
 *
 * @param state
 * @param methodName
 */
function getOrCreateConfig(state, methodName) {
    var config = methodName === null ? state.root : state.methods.get(methodName);
    if (!config) {
        return createRouteConfig();
    }
    return config;
}
exports.getOrCreateConfig = getOrCreateConfig;
/**
 * Gets the config state from the target.
 *
 * @param target
 */
function getState(target) {
    return ((target && (target.prototype ? target.prototype[symbols_1.STATE] : target[symbols_1.STATE])) ||
        null);
}
exports.getState = getState;
/**
 * Sets the config state on the target.
 *
 * @param target
 * @param state
 */
function setState(target, state) {
    if (target.prototype) {
        target.prototype[symbols_1.STATE] = state;
    }
    else {
        target[symbols_1.STATE] = state;
    }
    return state;
}
exports.setState = setState;
/**
 * Updates the state on the specified target by invoking the callback with the previous state.
 *
 * @param target
 * @param updater
 */
function updateState(target, updater) {
    setState(target, updater(getOrInitStateForDecoratorTarget(target)));
}
exports.updateState = updateState;
/**
 * Gets or initializes the state for a decorated target
 *
 * @param target
 * @param name
 */
function getOrInitStateForDecoratorTarget(target) {
    return getState(target) || createState();
}
exports.getOrInitStateForDecoratorTarget = getOrInitStateForDecoratorTarget;
/**
 * Creates a new state object.
 */
function createState() {
    var state = {
        root: createRouteConfig(),
        methods: new Map()
    };
    return state;
}
exports.createState = createState;
/**
 * Updates a config on a state, returns the new state.
 *
 * @param state
 * Existing state.
 *
 * @param methodName
 * If null, updates the root config. Else, the method config.
 *
 * @param newConfig
 * Config to shallow-merge in.
 */
function updateConfig(state, methodName, newConfig) {
    var existing = getOrCreateConfig(state, methodName);
    var mergedConfig = tslib_1.__assign({}, existing, newConfig);
    // Root update is simple.
    if (methodName === null) {
        return tslib_1.__assign({}, state, { root: mergedConfig });
    }
    // Filters out the entry we're replacing.
    var filteredEntries = Array.from(state.methods.entries()).filter(function (_a) {
        var key = _a[0];
        return key !== methodName;
    });
    return tslib_1.__assign({}, state, { methods: new Map(filteredEntries.concat([[methodName, mergedConfig]])) });
}
exports.updateConfig = updateConfig;
/**
 * Creates a new route config object.
 */
function createRouteConfig() {
    return {
        paths: [],
        beforeMiddleware: [],
        afterMiddleware: [],
        verbs: []
    };
}
exports.createRouteConfig = createRouteConfig;
/**
 * Adds a middleware to the end of the target array.
 *
 * @param targetArray
 * @param value
 */
function addMiddleware(targetArray, value) {
    return Array.isArray(value)
        ? targetArray.concat(value) : targetArray.concat([value]);
}
/**
 * Concatenates root and method paths so we have one for each combination.
 */
function concatPaths(rootPaths, methodPaths) {
    if (rootPaths.length === 0) {
        return methodPaths.slice();
    }
    var result = [];
    rootPaths.forEach(function (rootPath) {
        if (methodPaths.length === 0) {
            result.push(rootPath);
        }
        else {
            methodPaths.forEach(function (methodPath) {
                result.push(rootPath + methodPath);
            });
        }
    });
    return result;
}
//# sourceMappingURL=state-util.js.map